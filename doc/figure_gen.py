# -*- coding: utf-8 -*-

from os import lseek
from intelhex import IntelHex

# +-> X
# |
# v
# Y

I = ['####', '0#00', '####', '0#00',
     '0000', '0#00', '0000', '0#00',
     '0000', '0#00', '0000', '0#00',
     '0000', '0#00', '0000', '0#00']

J = ['#000', '0#00', '###0', '##00',
     '###0', '0#00', '00#0', '#000',
     '0000', '##00', '0000', '#000',
     '0000', '0000', '0000', '0000']

L = ['00#0', '##00', '###0', '#000',
     '###0', '0#00', '#000', '#000',
     '0000', '0#00', '0000', '##00',
     '0000', '0000', '0000', '0000']

O = ['##00', '##00', '##00', '##00',
     '##00', '##00', '##00', '##00',
     '0000', '0000', '0000', '0000',
     '0000', '0000', '0000', '0000']

S = ['0##0', '#000', '0##0', '#000',
     '##00', '##00', '##00', '##00',
     '0000', '0#00', '0000', '0#00',
     '0000', '0000', '0000', '0000']

T = ['0#00', '0#00', '###0', '#000',
     '###0', '##00', '0#00', '##00',
     '0000', '0#00', '0000', '#000',
     '0000', '0000', '0000', '0000']

Z = ['##00', '0#00', '##00', '0#00',
     '0##0', '##00', '0##0', '##00',
     '0000', '#000', '0000', '#000',
     '0000', '0000', '0000', '0000']

x_coord = []
y_coord = []

for i in [I, J, L, O, S, T, Z]:
    for f in range(4):
        for x in range(4):
            for y in range(4):
                if i[f + y*4][x] == '#':
                    # Инвертируем, т.к. выход ПЗУ = инверсный
                    x_coord.append(x ^ 3)
                    y_coord.append(y ^ 3)

# print(coord)

'''
MSB             LSB
0000 0000 0000 0000
                 \--x0
               \----x1
            \-------x2
          \---------x3
       \------------y0
     \--------------y1
  \-----------------y2
\-------------------y3
'''

offset = 32

hex = IntelHex()
for i in range(int(len(x_coord) / 4)):
     x = x_coord[i*4:i*4+4]
     y = y_coord[i*4:i*4+4]
     hex.puts(i,           bytes([x[0] + (x[1] << 2) + (x[2] << 4) + (x[3] << 6)]))
     hex.puts(i + offset, bytes([y[0] + (y[1] << 2) + (y[2] << 4) + (y[3] << 6)]))
hex.write_hex_file('../proteus/figure.hex', byte_count = 16)

print(f'Writed {hex.maxaddr() + 1} bytes to figure.hex.')

# Y
# ^
# Y
# +-> X

rect = {}

rect['full'] = [
     '# # 0 0 0 0 0 0 # #',
     '# 0 # 0 # 0 # 0 # 0',
     '0 # 0 # 0 # 0 # 0 #',
     '# 0 # 0 # 0 # 0 # 0',
     '0 # 0 # 0 # 0 # 0 #',
     '# 0 # 0 # 0 # 0 # 0',
     '0 # 0 # 0 # 0 # 0 #',
     '# 0 # 0 # 0 # 0 # 0',
     '0 # 0 # 0 # 0 # 0 #',
     '# # 0 # 0 # 0 # 0 #',
     '# # 0 # 0 # 0 # 0 #',
     '0 # 0 # 0 # 0 # 0 0',
     '0 # 0 # 0 # 0 # 0 0',
     '# 0 # 0 # 0 # 0 # 0',
     '0 # 0 # 0 # 0 # 0 #',
     '# # # # # # # # # #',
     '# 0 # 0 # 0 # 0 # 0',
     '0 # 0 # 0 # 0 # 0 #',
     '# # # # # # # # # #',
     '0 # 0 # 0 # 0 # 0 #',
     ]

rect['empty'] = [
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 0 0 0 0 0 0 0',
     '0 0 0 # 0 0 0 0 0 0',
     '0 0 0 # 0 0 0 0 0 0',
     '0 0 0 # 0 0 0 0 0 0',
     '# # # # # # # 0 0 0',
     ]

for k, v in rect.items():

     hexsz = 512
     strsz = 16
     rectangle = ''.join([''.join(i.split()).ljust(strsz, '0') for i in v]).rjust(hexsz, '0')
     dots = bytearray([])
     for y in range(int(hexsz / strsz)):
          for x in range(strsz):
              ch = rectangle[hexsz - ((y + 1)  * strsz) + x]
              d = 0 if ch == '0' else 0xFF
              dots.append(d)

     hex = IntelHex()
     hex.frombytes(dots)
     hex.write_hex_file(f'../proteus/k155ru5_{k}.hex', byte_count = strsz)

     print(f'Writed {hex.maxaddr() + 1} bytes to k155ru5_{k}.hex.')
